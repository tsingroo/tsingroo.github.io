---
author: admin
date: 2016-06-01 02:00:50+00:00
layout: post
title: Angular2 知识点整理
---

零零散散的知识点，相当于一份CheatSheet,记录一些官方文档没说清楚的地方，帮助你理解Angular2的设计，有错误地方请指出，系统学习请看官方文档。



**angular2&TypeScript&nodejs&npm&VisualStudio&sublime的关系:**

很多人迷惑于这几个的关系，现在给大家解释一下:
 - Angular是一个前端框架,可以理解为和jquery(jquery实际上是一个库)框架一样。
 - TypeScript是中间语言，通过翻译器翻译后转为javascript,至于翻译成什么框架的js那就是由映射文件(DefinitelyTyped,*.d.ts文件)决定的。
 - NodeJs是用js开发服务器端程序的一个环境。
 - npm是nodejs上用来管理js语言各种包的工具，类似于python的pip,.NET平台的NuGet或fedora系统的yum。
 - VS和SL都是编辑器，VS是比较强大的编辑器，Sublime是比较弱的编辑器。这两个编辑器最终都是调用命令行的工具完成检查和编译工作。

<!-- more -->

**关于Angular2中的变量和表达式:**

无论是

    *ngFor="let xx of xxx",
    *ngIf="xxxxx"
    (click)="xxxx(xx)"
    [hero]="xxxx"
    {{xxxxxxx}}

这些xxx不止是变量可以是任意复杂的表达式，都是作为一个可执行的单元被angular2绑定在视图上



**关于小括号()，方括号[],星号*的问题:**

参考[StackOverflow](http://stackoverflow.com/questions/27919650/angular-2-is-usage-of-parentheses-square-brackets-mandatory#answer-30863873)


 - []是属性绑定，()是注册事件,*是循环或者逻辑控制指令前缀。
 - []是从数据渲染到视图，()是从视图更新到数据
 - 所以[(ngModel)]就不难理解既有从数据到视图的，又有从视图到数据的，就实现了双向绑定




** 关于@input和@output**

参考[这里](https://www.sitepoint.com/angular-2-components-inputs-outputs/)

简单来说@input是定义一个属性值并绑定到UI上，@output定义一个事件并绑定到UI上。

这样的使用看起来毫无意义，但是如果你自定义或者封装了一些控件，并且加入了自定义的一些事件，并且要绑定自己写的一些方法的时候这种才有用武之地。

比如：你用div封装了一个innerDiv,这时可以在这个innerDiv中加入自定义NewEvent事件或者只是传递一下click事件。然后在页面上的时候写一个函数绑定到这个NewEvent上。

    input和output有两种使用方式：
    第一种在Class类内使用metadata声明方式
    export class ClassA{
    	@input heroName;
    	@output newEvent;
    }
    第二种在@component中引用
    @Component({
    	selector:'',
    	inputs:[heroName],
    	outputs:[newEvent]
    })
    export class ClassA{
    	heroName:string;
    	newEvent:EventEmitter;
    }




** Form相关的几个点:**

 - NgForm是从angular/common引入的，而不是angular/core
 - 给一个控件加上NgControl指令，就把这个控件添加到Angular中监视起来。控件如果有变化会反映到控件的数据上。
 - 控件上使用Local Variable获取到的是原始控件的Dom，如果在NgControl上给Local Variable赋值NgForm,就会把Angular监视的这个控件的对象赋值到Local Variable上，从而替换原始的Dom变量(NgControl这个指令的ExportAs属性是NgForm,同时Angular会把Form标签处理成NgControl)
 - Angular的Form标签没有处理URL,数据的提交是有NgSubmit指令指定的方法完成。




**依赖注入:**

 - 依赖注入单从一个类的设计上看，是把在类内实例化的一些对象，通过参数传递过来。
 - 从更高一级的两个文件的依赖上看，就是B如果依赖A,如果实例化A需要点特殊的改动，不应该去更改已经完成的A类，而应该通过A上层的改动实现A提供了其他的特殊功能。
 - 就是通过更高层的抽象实现了下层细节的屏蔽。
 - 以上就是依赖注入。而类似于Angular2的所有的依赖注入框架提供的Injector.ResoveAndCreate()这样的方法是为了解决上层（B类）实例化A类需要的一些东西而提出的一个简化实例化的工具，而不一定非要包含在依赖注入框架里面。




**模板相关：**

内容全部截取自[这里](https://angular.io/docs/ts/latest/guide/template-syntax.html)

HTML attribute vs. DOM property

The distinction between an HTML attribute and a DOM property is crucial to understanding how Angular binding works.

Attributes are defined by HTML. Properties are defined by the DOM (Document Object Model).

Attributes initialize DOM properties and then they are done. Property values can change; attribute values can't.

The HTML attribute and the DOM property are not the same thing, even when they have the same name.

Template binding works with properties and events, not attributes.

    下面两个语句是等效的:
    <img [src]="heroImageUrl">
    <img bind-src="heroImageUrl">
    下面两个语句也是等效的：
    <input [(ngModel)]="currentHero.firstName">
    <input [ngModel]="currentHero.firstName"
    (ngModelChange)="currentHero.firstName=$event">




**Tutorial中Http章节的问题**

文章中引入了angular2-in-memory-web-api,这不是跟随Angular2一起发布的官方库，起码现在还没被包含在官方库内。

**如何安装angular2-in-memory-web-api(angular cli(system-config-js)管理框架下):**

 1. 切换到项目根目录，执行npm install angular2-in-memory-web-api
 2. packages.json的depencies节点加入"angular2-in-memory-web-api": "0.0.12"，其中0.0.12是web-api的版本
 3. angular-cli-build.js的vendorNpmFiles加入一行'angular2-in-memory-web-api/*.+(js|js.map)'
 4. src/system-config.ts的map对象中加入'angular2-in-memory-web-api': 'vendor/angular2-in-memory-web-api'


** 引入了in-memory-web-api的代码是如何工作的:**

 - 官方Http在内部实现上使用了XHRBackend,in-memory-api通过重写XHRBackend这个类（srategy模式或tempalte method模式?）实现了对Http的重写。
 - 当你在程序里使用this.http.get(someUrl)的时候，并不是通过原先提供的方法走http请求someUrl,而是找到一个someUrl的路径获取的文件内的数据。
 - 这里体现了依赖注入的好处，代码里还是一样的写法，但是Http类已经被in-memoryweb-api替换掉了，这个替换只是加了一句useClass:InMemoryBackendService
